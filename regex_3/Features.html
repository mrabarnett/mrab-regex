<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 6194 2009-11-11 12:05:10Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left{
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="section" id="introduction">
<h1>Introduction</h1>
<p>This new regex implementation is intended eventually to replace Python's current re module implementation.</p>
<p>For testing and comparison with the current 're' module the new implementation is in the form of a module called 'regex'.</p>
<p>Also included are the compiled binary .pyd files for Python 2.5-2.7 and Python 3.1-3.2 on 32-bit Windows.</p>
</div>
<div class="section" id="change-of-behaviour">
<h1>Change of behaviour</h1>
<p><strong>Old vs new behaviour</strong></p>
<p>This module has 2 behaviours:</p>
<p>Version 0 behaviour (old behaviour, compatible with the current 're' module):</p>
<blockquote>
<p>Indicated by the <tt class="docutils literal">VERSION0</tt> or <tt class="docutils literal">V0</tt> flag, or <tt class="docutils literal"><span class="pre">(?V0)</span></tt> in the pattern.</p>
<p><tt class="docutils literal">.split</tt> won't split a string at a zero-width match.</p>
<p>Inline flags apply to the entire pattern, and they can't be turned off.</p>
<p>Only simple sets are supported.</p>
<p>Case-insensitive matches in Unicode use simple case-folding by default.</p>
</blockquote>
<p>Version 1 behaviour (new behaviour, different from the current 're' module):</p>
<blockquote>
<p>Indicated by the <tt class="docutils literal">VERSION1</tt> or <tt class="docutils literal">V1</tt> flag, or <tt class="docutils literal"><span class="pre">(?V1)</span></tt> in the pattern.</p>
<p><tt class="docutils literal">.split</tt> will split a string at a zero-width match.</p>
<p>Inline flags apply to the end of the group or pattern, and they can be turned off.</p>
<p>Nested sets and set operations are supported.</p>
<p>Case-insensitive matches in Unicode use full case-folding by default.</p>
</blockquote>
<p>If no version is specified, the regex module will default to <tt class="docutils literal">regex.DEFAULT_VERSION</tt>. In the short term this will be <tt class="docutils literal">VERSION0</tt>, but in the longer term it will be <tt class="docutils literal">VERSION1</tt>.</p>
<p><strong>Note</strong>: the <tt class="docutils literal">VERSION1</tt> flag replaces the <tt class="docutils literal">NEW</tt> flag in previous versions of this module. The <tt class="docutils literal">NEW</tt> flag has been removed. The decision about versions and making the change was made after discussion in the python-dev list.</p>
<p><strong>Case-insensitive matches in Unicode</strong></p>
<p>The regex module supports both simple and full case-folding for case-insensitive matches in Unicode. Use of full case-folding can be turned on using the <tt class="docutils literal">FULLCASE</tt> or <tt class="docutils literal">F</tt> flag, or <tt class="docutils literal"><span class="pre">(?f)</span></tt> in the pattern. Please note that this flag affects how the <tt class="docutils literal">IGNORECASE</tt> flag works; the <tt class="docutils literal">FULLCASE</tt> flag itself does not turn on case-insensitive matching.</p>
<p>In the version 0 behaviour, the flag is off by default.</p>
<p>In the version 1 behaviour, the flag is on by default.</p>
<p><strong>Nested sets and set operations</strong></p>
<p>Previous releases supported both simple and nested sets at the same time. This occasionally lead to problems in practice when an unescaped &quot;[&quot; in a simple set was interpreted as being the start of a nested set. Therefore nested sets and set operations are now supported only in the version 1 behaviour.</p>
<p>Version 0 behaviour: only simple sets are supported.</p>
<p>Version 1 behaviour: nested sets and set operations are supported.</p>
<p><strong>Fuzzy matching</strong></p>
<p>When performing fuzzy matching, the previous release of this module searched for the best match. This proved to be confusing in practice when used with <tt class="docutils literal">.findall</tt>, for example.</p>
<p>Therefore, the default behaviour has been changed to search for the first match which meets the constraints, and a new <tt class="docutils literal">BESTMATCH</tt> flag has been added to force it to search for the best match instead (the previous behaviour).</p>
</div>
<div class="section" id="flags">
<h1>Flags</h1>
<p>There are 2 kinds of flag: scoped and global. Scoped flags can apply to only part of a pattern and can be turned on or off; global flags apply to the entire pattern and can only be turned on.</p>
<p>The scoped flags are: <tt class="docutils literal">FULLCASE</tt>, <tt class="docutils literal">IGNORECASE</tt>, <tt class="docutils literal">MULTILINE</tt>, <tt class="docutils literal">DOTALL</tt>, <tt class="docutils literal">VERBOSE</tt>, <tt class="docutils literal">WORD</tt>.</p>
<p>The global flags are: <tt class="docutils literal">ASCII</tt>, <tt class="docutils literal">BESTMATCH</tt>, <tt class="docutils literal">LOCALE</tt>, <tt class="docutils literal">REVERSE</tt>, <tt class="docutils literal">UNICODE</tt>, <tt class="docutils literal">VERSION0</tt>, <tt class="docutils literal">VERSION1</tt>.</p>
<p>If neither the <tt class="docutils literal">ASCII</tt>, <tt class="docutils literal">LOCALE</tt> nor <tt class="docutils literal">UNICODE</tt> flag is specified, it will default to <tt class="docutils literal">UNICODE</tt> if the regex pattern is a Unicode string and <tt class="docutils literal">ASCII</tt> if it's a bytestring.</p>
<p>The <tt class="docutils literal">BESTMATCH</tt> flag makes fuzzy matching search for the best match instead of the next match which meets the given constraints.</p>
</div>
<div class="section" id="notes-on-named-capture-groups">
<h1>Notes on named capture groups</h1>
<p>All capture groups have a group number, starting from 1.</p>
<p>Groups with the same group name will have the same group number, and groups with a different group name will have a different group number.</p>
<p>The same group name can be used on different branches of an alternation because they are mutually exclusive, eg. <tt class="docutils literal"><span class="pre">(?P&lt;foo&gt;first)|(?P&lt;foo&gt;second)</span></tt>. They will, of course, have the same group number.</p>
<p>Group numbers will be reused, where possible, across different branches of a branch reset, eg. <tt class="docutils literal"><span class="pre">(?|(first)|(second))</span></tt> has only group 1. If capture groups have different group names then they will, of course, have different group numbers, eg. <tt class="docutils literal"><span class="pre">(?|(?P&lt;foo&gt;first)|(?P&lt;bar&gt;second))</span></tt> has group 1 (&quot;foo&quot;) and group 2 (&quot;bar&quot;).</p>
</div>
<div class="section" id="multithreading">
<h1>Multithreading</h1>
<p>The regex module releases the GIL during matching on instances of the built-in (immutable) string classes, enabling other Python threads to run concurrently. It is also possible to force the regex module to release the GIL during matching by calling the matching methods with the keyword argument <tt class="docutils literal">concurrent=True</tt>. The behaviour is undefined if the string changes during matching, so use it <em>only</em> when it is guaranteed that that won't happen.</p>
</div>
<div class="section" id="building-for-64-bits">
<h1>Building for 64-bits</h1>
<p>If the source files are built for a 64-bit target then the string positions will also be 64-bit. (The 're' module appears to limit string positions to 32 bits, even on a 64-bit build.)</p>
</div>
<div class="section" id="unicode">
<h1>Unicode</h1>
<p>This module supports Unicode 6.0.0.</p>
<p>Full Unicode case-folding is supported.</p>
</div>
<div class="section" id="additional-features">
<h1>Additional features</h1>
<p>The issue numbers relate to the Python bug tracker, except where listed as &quot;Hg issue&quot;.</p>
<ul>
<li><p class="first">Recursive patterns (Hg issue 27)</p>
<blockquote>
<p>Recursive regexes are supported. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; m = regex.search(r&quot;(\w)(?:(?R)|(\w?))\1&quot;, &quot;kayak&quot;)
&gt;&gt;&gt; m.group(0, 1, 2)
('kayak', 'k', None)
</pre>
<p><tt class="docutils literal"><span class="pre">(?R)</span></tt> or <tt class="docutils literal"><span class="pre">(?0)</span></tt> tries to match the entire regex recursively. <tt class="docutils literal"><span class="pre">(?1)</span></tt>, <tt class="docutils literal"><span class="pre">(?2)</span></tt>, etc, try to match the relevant capture group.</p>
<p><tt class="docutils literal"><span class="pre">(?&amp;name)</span></tt> tries to match the named capture group.</p>
<p>It's possible to backtrack into a recursed group.</p>
<p>The alternative forms <tt class="docutils literal"><span class="pre">(?P&gt;name)</span></tt> and <tt class="docutils literal"><span class="pre">(?P&amp;name)</span></tt> are also supported.</p>
</blockquote>
</li>
<li><p class="first">repr(regex) doesn't include actual regex (issue #13592)</p>
<blockquote>
<p>The repr of a compiled regex is now in the form of a eval-able string. For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; r = regex.compile(&quot;foo&quot;, regex.I)
&gt;&gt;&gt; repr(r)
&quot;regex.Regex('foo', flags=regex.I | regex.V0)&quot;
&gt;&gt;&gt; r
regex.Regex('foo', flags=regex.I | regex.V0)
</pre>
<p>The regex module has Regex as an alias for the 'compile' function.</p>
</blockquote>
</li>
<li><p class="first">Python lib re cannot handle Unicode properly due to narrow/wide bug (issue #12729)</p>
<blockquote>
<p>The source code of the regex module has been updated to support PEP 393 (&quot;Flexible String Representation&quot;), which will be new in Python 3.3.</p>
</blockquote>
</li>
<li><p class="first">Full Unicode case-folding is supported.</p>
<blockquote>
<p>When performing case-insensitive matches in Unicode, regex uses full case-folding.</p>
<p>Examples (in Python 3):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; regex.match(r&quot;(?i)strasse&quot;, &quot;stra\N{LATIN SMALL LETTER SHARP S}e&quot;).span()
(0, 6)
&gt;&gt;&gt; regex.match(r&quot;(?i)stra\N{LATIN SMALL LETTER SHARP S}e&quot;, &quot;STRASSE&quot;).span()
(0, 7)
</pre>
</blockquote>
</blockquote>
</li>
<li><p class="first">Approximate &quot;fuzzy&quot; matching (Hg issue 12, Hg issue 41)</p>
<blockquote>
<p>Regex usually attempts an exact match, but sometimes an approximate, or &quot;fuzzy&quot;, match is needed, for those cases where the text being searched may contain errors in the form of inserted, deleted or substituted characters.</p>
<p>A fuzzy regex specifies which types of errors are permitted, and, optionally, either the minimum and maximum or only the maximum permitted number of each type. (You cannot specify only a minimum.)</p>
<p>The 3 types of error are:</p>
<ul class="simple">
<li>Insertion, indicated by &quot;i&quot;</li>
<li>Deletion, indicated by &quot;d&quot;</li>
<li>Substitution, indicated by &quot;s&quot;</li>
</ul>
<p>In addition, &quot;e&quot; indicates any type of error.</p>
<p>The fuzziness of a regex item is specified between &quot;{&quot; and &quot;}&quot; after the item.</p>
<p>Examples:</p>
<p><tt class="docutils literal">foo</tt> match &quot;foo&quot; exactly</p>
<p><tt class="docutils literal"><span class="pre">(?:foo){i}</span></tt> match &quot;foo&quot;, permitting insertions</p>
<p><tt class="docutils literal"><span class="pre">(?:foo){d}</span></tt> match &quot;foo&quot;, permitting deletions</p>
<p><tt class="docutils literal"><span class="pre">(?:foo){s}</span></tt> match &quot;foo&quot;, permitting substitutions</p>
<p><tt class="docutils literal"><span class="pre">(?:foo){i,s}</span></tt> match &quot;foo&quot;, permitting insertions and substitutions</p>
<p><tt class="docutils literal"><span class="pre">(?:foo){e}</span></tt> match &quot;foo&quot;, permitting errors</p>
<p>If a certain type of error is specified, then any type not specified will <strong>not</strong> be permitted.</p>
<p>In the following examples I'll omit the item and write only the fuzziness.</p>
<p><tt class="docutils literal"><span class="pre">{i&lt;=3}</span></tt> permit at most 3 insertions, but no other types</p>
<p><tt class="docutils literal"><span class="pre">{d&lt;=3}</span></tt> permit at most 3 deletions, but no other types</p>
<p><tt class="docutils literal"><span class="pre">{s&lt;=3}</span></tt> permit at most 3 substitutions, but no other types</p>
<p><tt class="docutils literal"><span class="pre">{i&lt;=1,s&lt;=2}</span></tt> permit at most 1 insertion and at most 2 substitutions, but no deletions</p>
<p><tt class="docutils literal"><span class="pre">{e&lt;=3}</span></tt> permit at most 3 errors</p>
<p><tt class="docutils literal"><span class="pre">{1&lt;=e&lt;=3}</span></tt> permit at least 1 and at most 3 errors</p>
<p><tt class="docutils literal"><span class="pre">{i&lt;=2,d&lt;=2,e&lt;=3}</span></tt> permit at most 2 insertions, at most 2 deletions, at most 3 errors in total, but no substitutions</p>
<p>It's also possible to state the costs of each type of error and the maximum permitted total cost.</p>
<p>Examples:</p>
<p><tt class="docutils literal"><span class="pre">{2i+2d+1s&lt;=4}</span></tt> each insertion costs 2, each deletion costs 2, each substitution costs 1, the total cost must not exceed 4</p>
<p><tt class="docutils literal"><span class="pre">{i&lt;=1,d&lt;=1,s&lt;=1,2i+2d+1s&lt;=4}</span></tt> at most 1 insertion, at most 1 deletion, at most 1 substitution; each insertion costs 2, each deletion costs 2, each substitution costs 1, the total cost must not exceed 4</p>
<p>You can also use &quot;&lt;&quot; instead of &quot;&lt;=&quot; if you want an exclusive minimum or maximum:</p>
<p><tt class="docutils literal"><span class="pre">{e&lt;=3}</span></tt> permit up to 3 errors</p>
<p><tt class="docutils literal">{e&lt;4}</tt> permit fewer than 4 errors</p>
<p><tt class="docutils literal">{0&lt;e&lt;4}</tt> permit more than 0 but fewer than 4 errors</p>
<p>By default, fuzzy matching searches for the first match which meets the given constraints, but turning on the <tt class="docutils literal">BESTMATCH</tt> flag will make it search for the best match instead.</p>
<p>When matching a fuzzy regex which contains a minimum, the regex module will first attempt a match while ignoring the minimum, and then reject it, continuing from where the match finished, if there were too few errors.</p>
</blockquote>
</li>
<li><p class="first">Named lists (Hg issue 11)</p>
<blockquote>
<p><tt class="docutils literal">\L&lt;name&gt;</tt></p>
<p>There are occasions where you may want to include a list (actually, a set) of options in a regex.</p>
<p>One way is to build the pattern like this:</p>
<pre class="literal-block">
p = regex.compile(r&quot;first|second|third|fourth|fifth&quot;)
</pre>
<p>but if the list is large, parsing the resulting regex can take considerable time, and care must also be taken that the strings are properly escaped if they contain any character which has a special meaning in a regex, and that if there is a shorter string which occurs initially in a longer string that the longer string is listed before the shorter one, for example, &quot;cats&quot; before &quot;cat&quot;.</p>
<p>The new alternative is to use a named list:</p>
<pre class="literal-block">
option_set = [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;, &quot;fifth&quot;]
p = regex.compile(r&quot;\L&lt;options&gt;&quot;, options=option_set)
</pre>
<p>The order of the items is irrelevant, they are treated as a set. The named lists are available as the <tt class="docutils literal">.named_lists</tt> attribute of the pattern object</p>
<pre class="literal-block">
&gt;&gt;&gt; print(p.named_lists)
{'options': frozenset({'second', 'fifth', 'fourth', 'third', 'first'})}
</pre>
</blockquote>
</li>
<li><p class="first">Start and end of word</p>
<blockquote>
<p><tt class="docutils literal">\m</tt> matches at the start of a word.</p>
<p><tt class="docutils literal">\M</tt> matches at the end of a word.</p>
<p>Compare with <tt class="docutils literal">\b</tt>, which matches at the start or end of a word.</p>
</blockquote>
</li>
<li><p class="first">Unicode line separators</p>
<blockquote>
<p>Normally the only line separator is <tt class="docutils literal">\n</tt> (<tt class="docutils literal">\x0A</tt>), but if the <tt class="docutils literal">WORD</tt> flag is turned on then the line separators are the pair <tt class="docutils literal">\x0D\x0A</tt>, and <tt class="docutils literal">\x0A</tt>, <tt class="docutils literal">\x0B</tt>, <tt class="docutils literal">\x0C</tt> and <tt class="docutils literal">\x0D</tt>, plus <tt class="docutils literal">\x85</tt>, <tt class="docutils literal">\u2028</tt> and <tt class="docutils literal">\u2029</tt> when working with Unicode.</p>
<p>This affects the regex dot <tt class="docutils literal">&quot;.&quot;</tt>, which, with the <tt class="docutils literal">DOTALL</tt> flag turned off, matches any character except a line separator. It also affects the line anchors <tt class="docutils literal">^</tt> and <tt class="docutils literal">$</tt> (in multiline mode).</p>
</blockquote>
</li>
<li><p class="first">Set operators</p>
<blockquote>
<p><strong>Version 1 behaviour only</strong></p>
<p>Set operators have been added, and a set <tt class="docutils literal"><span class="pre">[...]</span></tt> can include nested sets.</p>
<p>The operators, in order of increasing precedence, are:</p>
<blockquote>
<p><tt class="docutils literal">||</tt> for union (&quot;x||y&quot; means &quot;x or y&quot;)</p>
<p><tt class="docutils literal">~~</tt> (double tilde) for symmetric difference (&quot;x~~y&quot; means &quot;x or y, but not both&quot;)</p>
<p><tt class="docutils literal">&amp;&amp;</tt> for intersection (&quot;x&amp;&amp;y&quot; means &quot;x and y&quot;)</p>
<p><tt class="docutils literal"><span class="pre">--</span></tt> (double dash) for difference (&quot;x--y&quot; means &quot;x but not y&quot;)</p>
</blockquote>
<p>Implicit union, ie, simple juxtaposition like in <tt class="docutils literal">[ab]</tt>, has the highest precedence. Thus, <tt class="docutils literal"><span class="pre">[ab&amp;&amp;cd]</span></tt> is the same as <tt class="docutils literal"><span class="pre">[[a||b]&amp;&amp;[c||d]]</span></tt>.</p>
<p>Examples:</p>
<blockquote>
<p><tt class="docutils literal">[ab]</tt> # Set containing 'a' and 'b'</p>
<p><tt class="docutils literal"><span class="pre">[a-z]</span></tt> # Set containing 'a' .. 'z'</p>
<p><tt class="docutils literal"><span class="pre">[[a-z]--[qw]]</span></tt> # Set containing 'a' .. 'z', but not 'q' or 'w'</p>
<p><tt class="docutils literal"><span class="pre">[a-z--qw]</span></tt> # Same as above</p>
<p><tt class="docutils literal"><span class="pre">[\p{L}--QW]</span></tt> # Set containing all letters except 'Q' and 'W'</p>
<p><tt class="docutils literal"><span class="pre">[\p{N}--[0-9]]</span></tt> # Set containing all numbers except '0' .. '9'</p>
<p><tt class="docutils literal"><span class="pre">[\p{ASCII}&amp;&amp;\p{Letter}]</span></tt> # Set containing all characters which are ASCII and letter</p>
</blockquote>
</blockquote>
</li>
<li><p class="first">regex.escape (issue #2650)</p>
<blockquote>
<p>regex.escape has an additional keyword parameter <tt class="docutils literal">special_only</tt>. When True, only 'special' regex characters, such as '?', are escaped.</p>
<p>Examples:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; regex.escape(&quot;foo!?&quot;)
'foo\\!\\?'
&gt;&gt;&gt; regex.escape(&quot;foo!?&quot;, special_only=True)
'foo!\\?'
</pre>
</blockquote>
</blockquote>
</li>
<li><p class="first">Repeated captures (issue #7132)</p>
<blockquote>
<p>A match object has additional methods which return information on all the successful matches of a repeated capture group. These methods are:</p>
<p><tt class="docutils literal"><span class="pre">matchobject.captures([group1,</span> <span class="pre">...])</span></tt></p>
<blockquote>
<p>Returns a list of the strings matched in a group or groups. Compare with <tt class="docutils literal"><span class="pre">matchobject.group([group1,</span> <span class="pre">...])</span></tt>.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">matchobject.starts([group])</span></tt></p>
<blockquote>
<p>Returns a list of the start positions. Compare with <tt class="docutils literal"><span class="pre">matchobject.start([group])</span></tt>.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">matchobject.ends([group])</span></tt></p>
<blockquote>
<p>Returns a list of the end positions. Compare with <tt class="docutils literal"><span class="pre">matchobject.end([group])</span></tt>.</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">matchobject.spans([group])</span></tt></p>
<blockquote>
<p>Returns a list of the spans. Compare with <tt class="docutils literal"><span class="pre">matchobject.span([group])</span></tt>.</p>
</blockquote>
<p>Examples:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; m = regex.search(r&quot;(\w{3})+&quot;, &quot;123456789&quot;)
&gt;&gt;&gt; m.group(1)
'789'
&gt;&gt;&gt; m.captures(1)
['123', '456', '789']
&gt;&gt;&gt; m.start(1)
6
&gt;&gt;&gt; m.starts(1)
[0, 3, 6]
&gt;&gt;&gt; m.end(1)
9
&gt;&gt;&gt; m.ends(1)
[3, 6, 9]
&gt;&gt;&gt; m.span(1)
(6, 9)
&gt;&gt;&gt; m.spans(1)
[(0, 3), (3, 6), (6, 9)]
</pre>
</blockquote>
</blockquote>
</li>
<li><p class="first">Atomic grouping (issue #433030)</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">(?&gt;...)</span></tt></p>
<p>If the following pattern subsequently fails, then the subpattern as a whole will fail.</p>
</blockquote>
</li>
<li><p class="first">Possessive quantifiers.</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">(?:...)?+</span></tt> ; <tt class="docutils literal"><span class="pre">(?:...)*+</span></tt> ; <tt class="docutils literal"><span class="pre">(?:...)++</span></tt> ; <tt class="docutils literal"><span class="pre">(?:...){min,max}+</span></tt></p>
<p>The subpattern is matched up to 'max' times. If the following pattern subsequently fails, then all of the repeated subpatterns will fail as a whole. For example, <tt class="docutils literal"><span class="pre">(?:...)++</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">(?&gt;(?:...)+)</span></tt>.</p>
</blockquote>
</li>
<li><p class="first">Scoped flags (issue #433028)</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">(?flags-flags:...)</span></tt></p>
<p>The flags will apply only to the subpattern. Flags can be turned on or off.</p>
</blockquote>
</li>
<li><p class="first">Inline flags (issue #433024, issue #433027)</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">(?flags-flags)</span></tt></p>
<p>Version 0 behaviour: the flags apply to the entire pattern, and they can't be turned off.</p>
<p>Version 1 behaviour: the flags apply to the end of the group or pattern, and they can be turned on or off.</p>
</blockquote>
</li>
<li><p class="first">Repeated repeats (issue #2537)</p>
<blockquote>
<p>A regex like <tt class="docutils literal"><span class="pre">((x|y+)*)*</span></tt> will be accepted and will work correctly, but should complete more quickly.</p>
</blockquote>
</li>
<li><p class="first">Definition of 'word' character (issue #1693050)</p>
<blockquote>
<p>The definition of a 'word' character has been expanded for Unicode. It now conforms to the Unicode specification at <tt class="docutils literal"><span class="pre">http://www.unicode.org/reports/tr29/</span></tt>. This applies to <tt class="docutils literal">\w</tt>, <tt class="docutils literal">\W</tt>, <tt class="docutils literal">\b</tt> and <tt class="docutils literal">\B</tt>.</p>
</blockquote>
</li>
<li><p class="first">Groups in lookahead and lookbehind (issue #814253)</p>
<blockquote>
<p>Groups and group references are permitted in both lookahead and lookbehind.</p>
</blockquote>
</li>
<li><p class="first">Variable-length lookbehind</p>
<blockquote>
<p>A lookbehind can match a variable-length string.</p>
</blockquote>
</li>
<li><p class="first">Correct handling of charset with ignore case flag (issue #3511)</p>
<blockquote>
<p>Ranges within charsets are handled correctly when the ignore-case flag is turned on.</p>
</blockquote>
</li>
<li><p class="first">Unmatched group in replacement (issue #1519638)</p>
<blockquote>
<p>An unmatched group is treated as an empty string in a replacement template.</p>
</blockquote>
</li>
<li><p class="first">'Pathological' patterns (issue #1566086, issue #1662581, issue #1448325, issue #1721518, issue #1297193)</p>
<blockquote>
<p>'Pathological' patterns should complete more quickly.</p>
</blockquote>
</li>
<li><p class="first">Flags argument for regex.split, regex.sub and regex.subn (issue #3482)</p>
<blockquote>
<p><tt class="docutils literal">regex.split</tt>, <tt class="docutils literal">regex.sub</tt> and <tt class="docutils literal">regex.subn</tt> support a 'flags' argument.</p>
</blockquote>
</li>
<li><p class="first">Pos and endpos arguments for regex.sub and regex.subn</p>
<blockquote>
<p><tt class="docutils literal">regex.sub</tt> and <tt class="docutils literal">regex.subn</tt> support 'pos' and 'endpos' arguments.</p>
</blockquote>
</li>
<li><p class="first">'Overlapped' argument for regex.findall and regex.finditer</p>
<blockquote>
<p><tt class="docutils literal">regex.findall</tt> and <tt class="docutils literal">regex.finditer</tt> support an 'overlapped' flag which permits overlapped matches.</p>
</blockquote>
</li>
<li><p class="first">Unicode escapes (issue #3665)</p>
<blockquote>
<p>The Unicode escapes <tt class="docutils literal">\uxxxx</tt> and <tt class="docutils literal">\Uxxxxxxxx</tt> are supported.</p>
</blockquote>
</li>
<li><p class="first">Large patterns (issue #1160)</p>
<blockquote>
<p>Patterns can be much larger.</p>
</blockquote>
</li>
<li><p class="first">Zero-width match with regex.finditer (issue #1647489)</p>
<blockquote>
<p><tt class="docutils literal">regex.finditer</tt> behaves correctly when it splits at a zero-width match.</p>
</blockquote>
</li>
<li><p class="first">Zero-width split with regex.split (issue #3262)</p>
<blockquote>
<p>Version 0 behaviour: a string won't be split at a zero-width match.</p>
<p>Version 1 behaviour: a string will be split at a zero-width match.</p>
</blockquote>
</li>
<li><p class="first">Splititer</p>
<blockquote>
<p><tt class="docutils literal">regex.splititer</tt> has been added. It's a generator equivalent of <tt class="docutils literal">regex.split</tt>.</p>
</blockquote>
</li>
<li><p class="first">Subscripting for groups</p>
<blockquote>
<p>A match object accepts access to the captured groups via subscripting and slicing:</p>
<pre class="doctest-block">
&gt;&gt;&gt; m = regex.search(r&quot;(?P&lt;before&gt;.*?)(?P&lt;num&gt;\d+)(?P&lt;after&gt;.*)&quot;, &quot;pqr123stu&quot;)
&gt;&gt;&gt; print m[&quot;before&quot;]
pqr
&gt;&gt;&gt; print m[&quot;num&quot;]
123
&gt;&gt;&gt; print m[&quot;after&quot;]
stu
&gt;&gt;&gt; print len(m)
4
&gt;&gt;&gt; print m[:]
('pqr123stu', 'pqr', '123', 'stu')
</pre>
</blockquote>
</li>
<li><p class="first">Named groups</p>
<blockquote>
<p>Groups can be named with <tt class="docutils literal"><span class="pre">(?&lt;name&gt;...)</span></tt> as well as the current <tt class="docutils literal"><span class="pre">(?P&lt;name&gt;...)</span></tt>.</p>
</blockquote>
</li>
<li><p class="first">Group references</p>
<blockquote>
<p>Groups can be referenced within a pattern with <tt class="docutils literal">\g&lt;name&gt;</tt>. This also allows there to be more than 99 groups.</p>
</blockquote>
</li>
<li><p class="first">Named characters</p>
<blockquote>
<p><tt class="docutils literal">\N{name}</tt></p>
<p>Named characters are supported. (Note: only those known by Python's Unicode database are supported.)</p>
</blockquote>
</li>
<li><p class="first">Unicode codepoint properties, including scripts and blocks</p>
<blockquote>
<p><tt class="docutils literal">\p{property=value}</tt>; <tt class="docutils literal">\P{property=value}</tt>; <tt class="docutils literal">\p{value}</tt> ; <tt class="docutils literal">\P{value}</tt></p>
<p>Many Unicode properties are supported, including blocks and scripts. <tt class="docutils literal">\p{property=value}</tt> or <tt class="docutils literal">\p{property:value}</tt> matches a character whose property <tt class="docutils literal">property</tt> has value <tt class="docutils literal">value</tt>. The inverse of <tt class="docutils literal">\p{property=value}</tt> is <tt class="docutils literal">\P{property=value}</tt> or <tt class="docutils literal"><span class="pre">\p{^property=value}</span></tt>.</p>
<p>If the short form <tt class="docutils literal">\p{value}</tt> is used, the properties are checked in the order: <tt class="docutils literal">General_Category</tt>, <tt class="docutils literal">Script</tt>, <tt class="docutils literal">Block</tt>, binary property:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">Latin</tt>, the 'Latin' script (<tt class="docutils literal">Script=Latin</tt>).</li>
<li><tt class="docutils literal">Cyrillic</tt>, the 'Cyrillic' script (<tt class="docutils literal">Script=Cyrillic</tt>).</li>
<li><tt class="docutils literal">BasicLatin</tt>, the 'BasicLatin' block (<tt class="docutils literal">Block=BasicLatin</tt>).</li>
<li><tt class="docutils literal">Alphabetic</tt>, the 'Alphabetic' binary property (<tt class="docutils literal">Alphabetic=Yes</tt>).</li>
</ol>
<p>A short form starting with <tt class="docutils literal">Is</tt> indicates a script or binary property:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">IsLatin</tt>, the 'Latin' script (<tt class="docutils literal">Script=Latin</tt>).</li>
<li><tt class="docutils literal">IsCyrillic</tt>, the 'Cyrillic' script (<tt class="docutils literal">Script=Cyrillic</tt>).</li>
<li><tt class="docutils literal">IsAlphabetic</tt>, the 'Alphabetic' binary property (<tt class="docutils literal">Alphabetic=Yes</tt>).</li>
</ol>
<p>A short form starting with <tt class="docutils literal">In</tt> indicates a block property:</p>
<ol class="arabic simple">
<li><tt class="docutils literal">InBasicLatin</tt>, the 'BasicLatin' block (<tt class="docutils literal">Block=BasicLatin</tt>).</li>
<li><tt class="docutils literal">InCyrillic</tt>, the 'Cyrillic' block (<tt class="docutils literal">Block=Cyrillic</tt>).</li>
</ol>
</blockquote>
</li>
<li><p class="first">POSIX character classes</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">[[:alpha:]]</span></tt>; <tt class="docutils literal"><span class="pre">[[:^alpha:]]</span></tt></p>
<p>POSIX character classes are supported. This is actually treated as an alternative form of <tt class="docutils literal"><span class="pre">\p{...}</span></tt>.</p>
</blockquote>
</li>
<li><p class="first">Search anchor</p>
<blockquote>
<p><tt class="docutils literal">\G</tt></p>
<p>A search anchor has been added. It matches at the position where each search started/continued and can be used for contiguous matches or in negative variable-length lookbehinds to limit how far back the lookbehind goes:</p>
<pre class="doctest-block">
&gt;&gt;&gt; regex.findall(r&quot;\w{2}&quot;, &quot;abcd ef&quot;)
['ab', 'cd', 'ef']
&gt;&gt;&gt; regex.findall(r&quot;\G\w{2}&quot;, &quot;abcd ef&quot;)
['ab', 'cd']
</pre>
<ol class="arabic simple">
<li>The search starts at position 0 and matches 2 letters 'ab'.</li>
<li>The search continues at position 2 and matches 2 letters 'cd'.</li>
<li>The search continues at position 4 and fails to match any letters.</li>
<li>The anchor stops the search start position from being advanced, so there are no more results.</li>
</ol>
</blockquote>
</li>
<li><p class="first">Reverse searching</p>
<blockquote>
<p>Searches can now work backwards:</p>
<pre class="doctest-block">
&gt;&gt;&gt; regex.findall(r&quot;.&quot;, &quot;abc&quot;)
['a', 'b', 'c']
&gt;&gt;&gt; regex.findall(r&quot;(?r).&quot;, &quot;abc&quot;)
['c', 'b', 'a']
</pre>
<p>Note: the result of a reverse search is not necessarily the reverse of a forward search:</p>
<pre class="doctest-block">
&gt;&gt;&gt; regex.findall(r&quot;..&quot;, &quot;abcde&quot;)
['ab', 'cd']
&gt;&gt;&gt; regex.findall(r&quot;(?r)..&quot;, &quot;abcde&quot;)
['de', 'bc']
</pre>
</blockquote>
</li>
<li><p class="first">Matching a single grapheme</p>
<blockquote>
<p><tt class="docutils literal">\X</tt></p>
<p>The grapheme matcher is supported. It now conforms to the Unicode specification at <tt class="docutils literal"><span class="pre">http://www.unicode.org/reports/tr29/</span></tt>.</p>
</blockquote>
</li>
<li><p class="first">Branch reset</p>
<blockquote>
<p>(?|...|...)</p>
<p>Capture group numbers will be reused across the alternatives.</p>
</blockquote>
</li>
<li><p class="first">Default Unicode word boundary</p>
<blockquote>
<p>The <tt class="docutils literal">WORD</tt> flag changes the definition of a 'word boundary' to that of a default Unicode word boundary. This applies to <tt class="docutils literal">\b</tt> and <tt class="docutils literal">\B</tt>.</p>
</blockquote>
</li>
<li><p class="first">SRE engine do not release the GIL (issue #1366311)</p>
<blockquote>
<p>The regex module can release the GIL during matching (see the above section on multithreading).</p>
<p>Iterators can be safely shared across threads.</p>
</blockquote>
</li>
</ul>
</div>
</div>
</body>
</html>
